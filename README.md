# jistol-spring-remote

Jistol-spring-remote v2.0 allows you to create Remote Server / Client with simple configuration.

Maven Installation
----
```xml
<dependencies>
    <dependency>
        <groupId>io.github.jistol</groupId>
        <artifactId>jistol-spring-remote</artifactId>
        <version>2.0.0</version>
    </dependency>
</dependencies>
```

Remote Server
----

You can set up Spring Remote Server(RMI,HttpInvoker) in only two steps.

Set @EnableRemoteServer on configuration file.

```java
@SpringBootApplication
@EnableRemoteServer
public class TestApplication {
  public static void main(String[] args) {
    SpringApplication.run(TestApplication.class, args);
  }
}
```

Add @RmiServer / @HttpInvokerServer on your service

```java
@Service("rmiService")
@RmiServer(serviceInterface = RmiService.class, port = "${test.rmi.port}")
public class RmiServiceImpl implements RmiService {
    @Value("${test.rmi.port}") private String rmiPort;

    @Override
    public String say() {
        Class clazz = this.getClass();
        return clazz.getName() +  "." + new Object(){}.getClass().getEnclosingMethod().getName() + ", rmiPort :" + rmiPort;
    }
}

@Service("/httpInvokerService")
@HttpInvokerServer(serviceInterface = HttpInvokerService.class)
public class HttpInvokerServiceImpl implements HttpInvokerService {
    @Value("${server.port}") private String testHttpPort;

    @Override public String say() {
        Class clazz = this.getClass();
        return clazz.getName() +  "." + new Object(){}.getClass().getEnclosingMethod().getName() + ", httpPort :" + testHttpPort;
    }
}
```

Remote Client
----

The Remote Client can be configured in two ways.

# 1. Annotation Base (@RmiClient / @HttpInvokerClient) #

Set @EnableRemoteClient  on configuration file with `basePackage`.

```java
@SpringBootApplication
@EnableRemoteClient(basePackage = "io.github.jistol.remote.test")
@RestController
public class TestApplication {
  public static void main(String[] args) {
    SpringApplication.run(TestApplication.class, args);
  }
}
```

Make only Client Interface.

```java
@RmiClient(ip = "${test.rmi.server.ip}", port = "${test.rmi.server.port}")
public interface RmiServiceClient {
    RmiService rmiService();
}

@HttpInvokerClient(ip = "${test.http.server.ip}", port = "${test.http.server.port}")
public interface HttpServiceClient {
    @RemoteContext(context = "httpInvokerService")
    HttpInvokerService httpInvokerService();
}
```

if you not use @RemoteContext, Automatically make remote context by method name.
If you use Annotation, it will be generated by Dynamic Proxy, which may cause some performance degradation. If you are sensitive to performance, please use as follows.

# 2. Use FactoryBeanUtil #

```java
@RequestMapping({"/rmi"})
public String sayProtocol()
{
    Class<DirectRmiService> type = DirectRmiService.class;
    RmiProxyFactoryBean rmiProxyFactoryBean = FactoryBeanUtil.getRmiProxyFactoryBean("rmi://" + rmiIp + ":" + rmiPort + "/directRmiService", type);
    return type.cast(rmiProxyFactoryBean.getObject()).say();
}

@RequestMapping({"/http"})
public String httpSayProtocol()
{
    Class<DirectHttpInvokerService> type = DirectHttpInvokerService.class;
    HttpInvokerProxyFactoryBean httpInvokerProxyFactoryBean = FactoryBeanUtil.getHttpInvokerProxyFactoryBean("http://" + httpIp + ":" + httpPort + "/directHttpInvokerService", type);
    return type.cast(httpInvokerProxyFactoryBean.getObject()).say();
}
```



